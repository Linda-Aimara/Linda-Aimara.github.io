---
title: "Evaluaci√≥n de la expresi√≥n diferencial en muestras de CD4‚Å∫ T cells con edgeR"
author: "Dra. Linda Aimara Kempis Calanis"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
---
## Librerias a utilizar 

```{r,warning=FALSE,message=FALSE}
library(limma) 
library(edgeR)
library(tximport)
library(ensembldb)
library(biomaRt)
library(EnhancedVolcano)
library(tidyverse)

```

## Leyendo los archivos .tsv


```{r}
# Obtiene una lista de todos los archivos en el directorio actual 
# cuyo nombre coincide con el patr√≥n ".tsv" (archivos de texto separados por tabulaciones).
FilesTSV<-list.files(pattern=".tsv")
FilesTSV
```
## Ensembl 
**useEnsembl()** proviene del paquete biomaRt, que conecta R con la base de datos Ensembl.

**getBM() (Get BioMart)** extrae datos seg√∫n los attributes (columnas deseadas) y el objeto mart (la conexi√≥n).

La variable **tx2gene1** suele usarse en an√°lisis de expresi√≥n g√©nica (por ejemplo, con tximport) para **mapear transcritos a genes**.

**hgnc_symbol** proviene del HUGO Gene Nomenclature Committee, y es la forma est√°ndar de nombrar genes humanos (por ejemplo, BRCA1, TP53).

```{r}
# Lee las primeras 10 filas del archivo TSV n√∫mero 6 de la lista 'FilesTSV'
# Esto permite inspeccionar r√°pidamente la estructura del archivo (columnas, formato, etc.)
read.delim(FilesTSV[6], nrow=10)

```
Nombrar las variables ensembl y tx2gene y hacer una ‚Äútraducci√≥n‚Äù a la nomenclatura hgnc_symbol

```{r}
# Conecta con la base de datos Ensembl (versi√≥n actual del servidor Ensembl)
# 'biomart = "ensembl"' indica el tipo de base de datos.
# 'dataset = "hsapiens_gene_ensembl"' especifica que se trabajar√° con genes humanos (Homo sapiens)
ensembl90 <- useEnsembl(biomart = 'ensembl', dataset="hsapiens_gene_ensembl")

# Obtiene una tabla con las relaciones entre los IDs de transcritos de Ensembl 
# (incluyendo la versi√≥n del transcrito) y los s√≠mbolos de genes seg√∫n HGNC (nomenclatura est√°ndar de genes humanos).
# Esto sirve para "traducir" los identificadores t√©cnicos de Ensembl a nombres de genes m√°s legibles.
tx2gene1 <- getBM(attributes = c("ensembl_transcript_id_version", "hgnc_symbol"), mart = ensembl90)

# Muestra las dimensiones del data frame resultante (n√∫mero de filas y columnas)
# para verificar cu√°ntos pares transcript_id - hgnc_symbol se obtuvieron.
dim(tx2gene1)
```
```{r}
# Calcula cu√°ntos valores faltantes (NA) hay en la columna 'hgnc_symbol' del data frame 'tx2gene1'.
# Esto sirve para saber cu√°ntos transcritos no tienen un s√≠mbolo de gen asociado en la base de datos HGNC.
sum(is.na(tx2gene1$hgnc_symbol))
# Muestra las primeras 6 filas del objeto 'tx2gene1' 

head(tx2gene1)

```

## Filtra las filas del objeto 'tx2gene1' eliminando aquellas donde 'hgnc_symbol' es NA.

```{r}
# Filtra las filas del objeto 'tx2gene1' eliminando aquellas donde 'hgnc_symbol' es NA.
# Es decir, conserva √∫nicamente los transcritos que tienen un s√≠mbolo de gen v√°lido seg√∫n HGNC.
tx2gene1 <- tx2gene1[!is.na(tx2gene1$hgnc_symbol), ]

# Verifica nuevamente el n√∫mero de filas despu√©s del filtrado,
# para confirmar cu√°ntos pares transcript_id / hgnc_symbol quedaron.
dim(tx2gene1)

# Opcional: mostrar las primeras filas del objeto limpio para inspeccionarlo.
head(tx2gene1)
```

Explicaci√≥n adicional:

- La expresi√≥n **!is.na(tx2gene1$hgnc_symbol)** genera un vector l√≥gico (TRUE / FALSE), y al usarlo entre corchetes [ ], se seleccionan solo las filas con valor TRUE, es decir, sin valores faltantes.

- Este filtrado es importante porque herramientas como tximport (usada para importar resultados de cuantificaci√≥n de expresi√≥n, por ejemplo de Salmon o Kallisto) necesitan un data frame sin valores vac√≠os para mapear correctamente los transcritos a genes.

## Importar las muestras cuantificadas con Kallisto


- **tximport()** es parte del paquete tximport, ampliamente usado para importar resultados de cuantificaci√≥n (de Kallisto, Salmon, o Sailfish) y resumirlos a nivel de gen.

Al usar tx2gene, tximport suma las abundancias o cuentas de todos los transcritos que pertenecen a un mismo gen.

El argumento **geneIdCol** = "hgnc_symbol" asegura que los genes en la matriz final est√©n nombrados con los s√≠mbolos humanos est√°ndar (por ejemplo, TP53, BRCA1).

El objeto resultante txi_kallisto1 contiene varios elementos, entre ellos:

- **counts:** matriz de cuentas crudas por gen.

- **abundance**: valores normalizados (TPM).

**length:** longitud promedio ponderada de los transcritos por gen.


```{r}
# Usa la funci√≥n tximport para leer los resultados de expresi√≥n g√©nica 
# provenientes de varios archivos TSV generados por Kallisto.
# Combina todos los resultados en un solo objeto listo para an√°lisis posteriores (por ejemplo, con edgeR,Dese2...).

txi_kallisto1 <- tximport(
  FilesTSV,        # Lista de archivos TSV generados por Kallisto (uno por muestra)
  type = "kallisto", # Especifica el tipo de cuantificador (en este caso, Kallisto)
  txIn = TRUE,       # Indica que las filas de los archivos corresponden a transcritos individuales
  txOut = FALSE,     # Indica que se desea resumir los datos a nivel de gen (no transcrito)
  tx2gene = tx2gene1,# Data frame que relaciona transcritos de Ensembl con sus s√≠mbolos de gen (HGNC)
  geneIdCol = "hgnc_symbol" # Define qu√© columna de tx2gene1 usar como identificador de gen
)

# Muestra las primeras filas de la matriz de conteos (genes x muestras)
# Esto permite verificar que los datos se importaron correctamente.
head(txi_kallisto1$counts)
```
Darle nombre a las columnas con nuestras muestras, tal como se leyeron en la variable FilesTSV

```{r}
# Renombra las columnas (muestras) del objeto 'txi_kallisto1$counts'
# Estas columnas corresponden a las muestras importadas desde los archivos TSV de Kallisto.
# Aqu√≠ se asignan nombres m√°s cortos y significativos para cada muestra:
# A1, A3, A4 = muestras del grupo A (por ejemplo, "tratadas")
# N2, N3, N5 = muestras del grupo N (por ejemplo, "control")
colnames(txi_kallisto1$counts) <- c("A1", "A3","A4","N2", "N3", "N5")
head(txi_kallisto1$counts)
```

## Tabla de conteos para EdgeR

**txi_kallisto1** es una lista que normalmente tiene varios elementos:

- $counts: matriz de conteos por gen.

- $abundance: valores normalizados (TPM o equivalentes).

- $length: longitudes efectivas promedio de los transcritos.

- **txi_kallisto1$counts** ‚Üí accede solo al componente con los conteos crudos

```{r}
head(txi_kallisto1$counts)
```
## Creaci√≥n de DGEList
Con la informaci√≥n de los conteos(txi_kallisto1) y el grupo de muestras(condition) formamos un objeto de tipo DGEList.


```{r}
# Crear un vector que indique la condici√≥n biol√≥gica de cada muestra.
# Debe coincidir en orden con las columnas de 'txi_kallisto1$counts':
# A1, A3, A4 ‚Üí Adultas (Adult_CD4_+_T_Cells)
# N2, N3, N5 ‚Üí Neonatales (Neonate_CD4_+_T_Cells)
# Crear vector de condicion
condition = factor(c("Adult_CD4_+_T_Cells", "Adult_CD4_+_T_Cells", "Adult_CD4_+_T_Cells",
"Neonate_CD4_+_T_Cells","Neonate_CD4_+_T_Cells", "Neonate_CD4_+_T_Cells"))
condition

```

```{r}
# Crear un objeto DGEList para an√°lisis de expresi√≥n diferencial con edgeR.
# Este objeto almacena la matriz de conteos y la informaci√≥n de grupos (condiciones).

dge <- DGEList(
  counts = txi_kallisto1$counts, # Matriz de conteos de genes (filas = genes, columnas = muestras)
  group = condition               # Vector con las condiciones biol√≥gicas (Adulto / Neonato)
)

# Verifica la clase del objeto para confirmar que se cre√≥ correctamente.
class(dge)
```
```{r}
dge
```
**DGEList()** es una funci√≥n del paquete edgeR que crea un objeto especial para manejar datos de conteo.

El objeto dge (Differential Gene Expression List) contiene varios componentes clave:

**counts:** la matriz original de conteos.

**samples:** metadatos de las muestras (nombres, grupo, tama√±o de biblioteca, etc.).

**genes:** (opcional) informaci√≥n sobre los genes si la agregas despu√©s.


**El factor de normalizaci√≥n** es 1 para todas las muestras, dado que no hemos normalizado.

## Normalizaci√≥n edgeR: la normalizaci√≥n por TMM (Trimmed Mean of M-values).

La funci√≥n calcNormFactors normaliza los datos mediante la b√∫squeda de un conjunto de factores de escala para cada biblioteca, que reduzcan al m√≠nimo los cambios entre las muestras para la mayor√≠a de los genes. El m√©todo utilizado para el c√°lculo de estos factores de escala es el TMM.

```{r}
colSums(txi_kallisto1$counts)
```
Como podemos observar loa tama√±os de las muestras son diferentes en cierta proporci√≥n.

Por default se utiliza el m√©todo TMM para normaizar
```{r}
dge<-calcNormFactors(dge,method="TMM")
dge$samples
```
```{r}
##Guardar tabla
cpms <- cpm(dge, log=FALSE)
# guarda la tabla cpms, la cual ser√≠a su tabla de conteos normalizada
write.table(cpms,file="cpms_edgeR_adultos_vs_neonatos.txt",sep="\t")


```

## Filtrado de genes con baja expresi√≥n

Los genes con muy pocos conteos en la mayor√≠a de las muestras no aportan informaci√≥n √∫til y pueden introducir ruido en el an√°lisis.
Por eso, primero filtramos los genes poco expresados.

```{r}
# Calcular la cantidad m√≠nima de lecturas promedio requerida (ej. 1 CPM)
# CPM = Counts Per Million = medida de abundancia normalizada por tama√±o de biblioteca
keep <- filterByExpr(dge, group = condition)

# Mantener solo los genes expresados adecuadamente
dge <- dge[keep, , keep.lib.sizes = FALSE]

# Ver cu√°ntos genes se conservaron
dge

```
**filterByExpr()** eval√∫a cada gen y conserva solo aquellos con niveles de expresi√≥n suficientes en al menos una condici√≥n.

**keep.lib.sizes** = FALSE recalcula los tama√±os de biblioteca despu√©s del filtrado.

## Estimar la dispersi√≥n

La dispersi√≥n mide la variabilidad biol√≥gica entre r√©plicas.
En edgeR, se estima en tres niveles: com√∫n, trended y tagwise.



## Analisis de nuestros datos Multi-dimensional scaling plot

El prop√≥sito del escalamiento multidimensional (MDS) es proporcionar una representaci√≥n visual del patr√≥n de proximidades (es decir, similitudes o distancias) entre un conjunto de objetos. El MDS toma un conjunto de similitudes y devuelve un conjunto de puntos cuyas distancias entre los puntos son aproximadamente iguales a las similitudes.

```{r}
# definiendo los colores de cada muestra
fnColors=c(3,3,3,4,4,4)
# graficando
plotMDS(dge,col=fnColors)
```

```{r, echo=FALSE}
# Cargar librer√≠as
library(ggplot2)

# Realizar el an√°lisis MDS sobre el objeto DGEList
mds <- plotMDS(dge, plot = FALSE)

# Crear un data frame con los resultados
mds_df <- data.frame(
  Sample = colnames(dge$counts),
  Dim1 = mds$x,
  Dim2 = mds$y,
  Group = condition
)

# Asignar colores seg√∫n el grupo
mds_colors <- c("Adult_CD4_+_T_Cells" = "forestgreen",
                "Neonate_CD4_+_T_Cells" = "steelblue")

# Crear el gr√°fico con ggplot2
ggplot(mds_df, aes(x = Dim1, y = Dim2, color = Group, label = Sample)) +
  geom_point(size = 4, alpha = 0.8) +
  geom_text(vjust = -1, size = 3.5) +
  scale_color_manual(values = mds_colors) +
  theme_minimal(base_size = 14) +
  labs(
    title = "MDS Plot - CD4+ T Cells (edgeR)",
    x = "Dim 1 (mayor variaci√≥n entre muestras)",
    y = "Dim 2 (segunda mayor variaci√≥n)",
    color = "Condici√≥n"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "top",
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90")
  )
# -----------
```

## Analisis de genes

Una vez que se normalizaron los datos, se hace el c√°lculo de la dispersi√≥n de los genes entre las muestras. Se pueden realizar dos tipos de c√°lculos de la dispersi√≥n de los genes, la denominada dispersi√≥n com√∫n y la dispersi√≥n por gen.


```{r}
## dispersi√≥n com√∫n
dge <- estimateCommonDisp(dge)
dge$common.dispersion

```
```{r}
## Calculando dispersi√≥n entre las muestras para cada gene
dge <- estimateTagwiseDisp(dge)
head(dge$tagwise.dispersion)
```

edgeR utiliza el m√©todo de m√°xima verosimilitud condicional ajustada por cuantiles (qCML) para el an√°lisis de expresiones de dise√±o unifactorial. El m√©todo qCML utiliza el pseudoconteo para ajustar el tama√±o de la biblioteca para todas las muestras. edgeR calcula internamente el pseudoconteo para agilizar el an√°lisis de la estimaci√≥n de la dispersi√≥n binomial negativa (NB) y la prueba exacta para la comparaci√≥n por pares.

La dispersi√≥n se estima mediante la funci√≥n estimateDisp(). Estima las dispersiones comunes y por gen en una sola ejecuci√≥n.

```{r}
dge <- estimateDisp(y = dge)
dge

```
Visualizaci√≥n de la dispersi√≥n

```{r}
plotBCV(dge)

```

Una vez que se hizo la normalizaci√≥n de los datos y el c√°lculo de la
dispersi√≥n de los genes, se puede efectuar el c√°lculo de la expresi√≥n
diferencial, utilizando la funci√≥n exactTest.
```{r}

# Realizar la prueba exacta (Exact Test) para expresi√≥n diferencial
# entre las dos condiciones: Neonate vs Adult.
# Esta prueba usa un modelo binomial negativo para evaluar si los conteos
# de cada gen difieren significativamente entre los grupos.
et = exactTest(dge,pair=c("Neonate_CD4_+_T_Cells","Adult_CD4_+_T_Cells"))

et
```

## üß† ¬øQu√© hace exactTest()?

Compara los dos grupos definidos (pair) usando un test exacto similar al test exacto de Fisher,
pero adaptado a conteos RNA-seq modelados con una distribuci√≥n binomial negativa.

Usa la dispersi√≥n estimada previamente (estimateDisp) para modelar la variabilidad entre r√©plicas.

Calcula para cada gen:

logFC: log‚ÇÇ fold change (diferencia en expresi√≥n entre grupos).

logCPM: abundancia promedio.

PValue: significancia estad√≠stica sin corregir.

üß¨ Resumen del flujo de trabajo RNA-seq

1Ô∏è‚É£ Importaci√≥n de archivos de cuantificaci√≥n (.tsv)
2Ô∏è‚É£ Creaci√≥n de la tabla de correspondencia (tx2gene)
3Ô∏è‚É£ Importaci√≥n de datos con tximport
4Ô∏è‚É£ Asignaci√≥n de nombres de muestras y condiciones experimentales
5Ô∏è‚É£ Creaci√≥n del objeto DGEList (edgeR)
6Ô∏è‚É£ Normalizaci√≥n de datos con TMM
7Ô∏è‚É£ Visualizaci√≥n de calidad mediante MDS Plot
8Ô∏è‚É£ An√°lisis de expresi√≥n diferencial con exactTest


##Clase de ma√±ana ##
topTags
La funci√≥n topTags() es √∫til para extraer la tabla con valores p ajustados (FDR). La tabla de salida se ordena por valores p.

Podemos interrogar los genes m√°s diferencialmente expresados toptags :

```{r}
topTags(et)

```


```{r}
summary(decideTests(object = et, lfc = ))

```


Vamos a asignar los resultados del c√°lculo de expresi√≥n diferencial al objeto resEdgeR y posteriormente seleccionaremos los genes que consideramos diferencialmente expresados

```{r}
resEdgeR<-topTags(et, n=Inf)$table
dim(resEdgeR)
head(resEdgeR)
```

Filter the genes based on the LFC and adjusted p-Value (|LFC|>=1 and p-adj<0.05).
```{r}
padj.cutoff <-0.05
lfc.cutoff<- 1
lfc_0 <-0

res_df1 <- resEdgeR %>% data.frame()%>% rownames_to_column(var="gene") %>% as_tibble()

sig1<- res_df1 %>% filter(FDR<= padj.cutoff & abs(logFC) >= lfc.cutoff)
dim(sig1)
sig_Neo <- res_df1 %>% filter(FDR<= padj.cutoff & logFC > lfc.cutoff)
dim(sig_Neo)
sig_Adul <- res_df1 %>% filter(FDR<= padj.cutoff & logFC <= -lfc.cutoff)
dim(sig_Adul)
```


```{r}
write.table(sig1,file="Neo_vs_Adultos_DiffExp_edgeR.txt",sep="\t", quote=F)
```



```{r}
plotMD(object = et)
abline(h=c(-1, 1), col="blue")
```



## Volcan plot
```{r}
color_volcan <- EnhancedVolcano(resEdgeR,
                lab = rownames(resEdgeR),
                title = "Genes diferencialmente expresados",
                subtitle = "Linfocitos T CD4+ Neonatos vs Adultos",
                x = 'logFC',
                y = 'PValue', 
                pointSize = 3.0,
                labSize = 4.0)

color_volcan

```


